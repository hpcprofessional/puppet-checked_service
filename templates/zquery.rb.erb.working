#!<%= @path_to_ruby %>
#This code borrows very heavily from zabby's trigger.zby script

#Let's define some exit codes in case we need them:
EXIT_TRIGGER_OKAY = 0
EXIT_TRIGGER_FAIL = 1
EXIT_UNKNOWN_ERROR = 99
EXIT_INCORRECT_NUMBER_OF_ARGUMENTS = 100
EXIT_NO_TRIGGER_POPULATED = 101
EXIT_TRIGGER_DESCRIPTION_MISSING = 102
EXIT_VALUE_NOT_FOUND_IN_TRIGGER_DATA=103

#if ARGV.length != 2
#  exit EXIT_INCORRECT_NUMBER_OF_ARGUMENTS
#end

#trigger_host = ARGV[0] 
#trigger_name = ARGV[1]
#

require "rubygems"
require "zabby"
require "pp"

def parse_args ()
  args = [
    ['utiappvmwebmq01','Health Check UCOMM1'],
    ['utiappvmwebmq01','Health Check UCOMM1'],
    ['utiappvmwebmq01','Health Check UCOMM1'],
    ['utiappvmwebmq01','Health Check UCOMM1'],
  ]

#This example should succeed
   # ['utiappvmwebmq01','Health Check UCOMM1'],
#This example should fail
   # ['3070-b','{HOST.NAME} SSL certificate expired'],
    return args
end

z = Zabby.init do
  set :server         => '<%= @zabbix_api_url %>'
  set :user           => '<%= @zabbix_user %>'
  set :password       => '<%= @zabbix_pass  %>'
  set :proxy_host     => '<%= @zabbix_proxy  %>'
  login
end

triggers = parse_args()

for trigger in triggers
  trigger_host = trigger[0]
  trigger_name = trigger[1]
  puts "Processing #{trigger_name} for #{trigger_host}"

  hh = Zabby::Host.get "filter" => {"name" => [trigger_host]}, "output" => "extend"

  for h in hh
    hostid = "#{h['hostid']}"
#    puts "hostid: #{h['hostid']}"

    tt = Zabby::Trigger.get "filter" => {"description" => "#{trigger_name}"}, "hostids" => hostid, "output" => "extend"
#      puts "tt: #{tt}"
    if tt == []
      exit EXIT_NO_TRIGGER_POPULATED
    end

    for t in tt
#   puts "t[value]: #{t["value"]}"
      if trigger_name == nil
        exit EXIT_TRIGGER_DESCRIPTION_MISSING
      elsif "value" == nil
        exit EXIT_VALUE_NOT_FOUND_IN_TRIGGER_DATA
      else 
        if t["value"].to_i == EXIT_TRIGGER_OKAY
          #puts "Trigger #{trigger_name} passed on #{trigger_host}."
          #If we make it to the end of loop without any failures, 
          #we'll send success
          #exit EXIT_TRIGGER_OKAY
        elsif t["value"].to_i == EXIT_TRIGGER_FAIL
          #puts "Trigger #{trigger_name} failed on #{trigger_host}."
          exit EXIT_TRIGGER_FAIL
        else
          exit EXIT_UNKNOWN_ERROR
        end
      end
    end
  end
end
  exit EXIT_TRIGGER_OKAY
